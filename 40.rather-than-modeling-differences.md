## Лучше сделать тип неточным, чем недостоверным

Отличная мысль для практики: если вы не уверены, лучше дать чуть более широкий (неточный) тип, чем “точный”, но неверный — ложная точность ломает пользователей и вызывает загадочные ошибки.
Ниже короткие, приземлённые примеры.

### 1) Слишком точный литеральный тип результата

Плохо (ложная точность):

```ts
// Обещаем, что всегда "success"
function doWork(): "success" {
  // ❌ может бросить, вернуть ошибку и т.п.
  if (Math.random() < 0.1) throw new Error("boom");
  return "success";
}
```

Лучше (честнее и полезнее):

```ts
type Result = "success" | "error";
function doWork(): Result {
  try {
    /* ... */ return "success";
  } catch {
    return "error";
  }
}
```

### 2) Точный кортеж вместо массива, когда длина не гарантируется

Плохо:

```ts
function split2(s: string): [string, string] {
  // ❌ не всякая строка делится на 2 части
  const parts = s.split(",");
  return [parts[0], parts[1]];
}
```

Лучше:

```ts
function splitCsv(s: string): string[] {
  // ✅ честно: длина переменная
  return s.split(",");
}
```

### 3) Перегрузка сигнатур, которые не соответствуют реализации

Плохо:

```ts
function getUser(x: number): { id: number; name: string };
function getUser(x: string): { id: string; name: string };
function getUser(x: number | string) {
  return { id: x, name: "Serii" }; // ❌ смешение типов id на практике
}
```

Лучше:

```ts
type Id = number | string;
function getUser(id: Id): { id: Id; name: string } {
  // ✅ честно отражает факт
  return { id, name: "Serii" };
}
```

### 4) Неверно узкое описание внешней библиотеки

Плохо:

```ts
// d.ts для сторонней fn — слишком узко
declare function ext(path: "/home" | "/about"): string; // ❌ на деле принимает любой URL
```

Лучше:

```ts
declare function ext(path: string): string; // ✅ чуть шире, но верно
```

5. JSON-данные: выдавать DTO без валидации — недостоверно
   Плохо:

```ts
// ❌ Обещаем точный тип, но без проверки
const user: { id: number; email: string } = JSON.parse(raw); // может прийти что угодно
```

Лучше:

```ts
type User = { id: number; email: string };
function parseUser(raw: string): User | undefined {
  const u = JSON.parse(raw);
  return u && typeof u.id === "number" && typeof u.email === "string" ? u : undefined; // ✅ честная неточность (может не распарситься)
}
```

### 6) Слишком строгие generic-ограничения

Плохо:

```ts
function keys<T extends { [k: string]: string }>(o: T): (keyof T)[] {
  return Object.keys(o) as (keyof T)[]; // ❌ не работает с number-значениями
}
```

Лучше:

```ts
function keys<T extends object>(o: T): (keyof T)[] {
  // ✅ шире, но верно
  return Object.keys(o) as (keyof T)[];
}
```

### 7) Неверно точный тип события

Плохо:

```ts
function onClick(handler: (e: MouseEvent) => void) {
  // ❌ иногда прилетит PointerEvent
  window.addEventListener("click", handler as any);
}
```

Лучше:

````ts
function onClick(handler: (e: Event) => void) {        // ✅ честнее
    window.addEventListener("click", handler);
}
    ```
(Если реально нужно MouseEvent, тогда делайте проверку в рантайме.)
8) Шаблонные строковые типы: слишком узко
### Плохо:
```ts
type URLStrict = `https://${string}.example.com`; // ❌ реальность шире: http, поддомены/пути
````

Лучше:

```ts
type URLish = `${"http" | "https"}://${string}`; // ✅ точность разумная, без фантазий
```

### 9) API-ответ «только success» — ловушка

Плохо:

```ts
type ApiOk<T> = { status: "ok"; data: T };
declare function fetchUser(): ApiOk<{ id: string }>; // ❌ на деле бывают ошибки
```

Лучше:

```ts
type ApiResult<T> = { status: "ok"; data: T } | { status: "error"; message: string };
declare function fetchUser(): ApiResult<{ id: string }>; // ✅ честно
```

### 10) Неправильная «точная» карта ключей

Плохо:

```ts
type Flags = { a: boolean; b: boolean }; // ❌ если ключи динамические
function hasAny(flags: Flags) {
  /* ... */
}
```

Лучше:

```ts
type Flags = Record<string, boolean>; // ✅ да, шире, но соответствует данным
```

Памятка
Если вы не уверены, что инвариант выдерживается всегда → расширьте тип.
Ложная точность → руинит DX (dev experience) и надёжность.
Чуть более «широкий», но правдивый тип проще поддерживать и безопаснее.
Хотите точнее? Делайте это после валидации/нормализации на границе.
