# Отдавайте предпочтение объединениям интерфейсов, а не интерфейсам с объединениями

Если вы создаете интерфейс, свойствами которого являются типы объединений,
спросите себя: не лучше ли создать этот тип как объединение более четко задан�
ных интерфейсов?

Коротко: когда поля интерфейса сами — это объединения (|),
вы допускаете «невозможные» комбинации свойств.
Лучше сделать объединение нескольких чётких интерфейсов (tagged union):
каждая ветка имеет свои обязательные поля, а «лишние» исключены на уровне типов.

## 1. Shape: невозможные комбинации vs. чёткие варианты

Плохо (union внутри полей):

```ts
interface Shape {
  kind: "circle" | "square";
  radius?: number; // для circle?
  side?: number; // для square?
}

const s: Shape = { kind: "circle", side: 10 }; // допустимо, но бессмысленно
```

Хорошо (объединение интерфейсов):

```ts
type Shape =
| { kind: "circle"; radius: number }
| { kind: "square"; side: number };

function area(s: Shape) {
    switch (s.kind) {
    case "circle": return Math.PI \* s.radius ** 2;
    case "square": return s.side ** 2;
     default: assertNever(s)
    }
}

```

→ Нет «невозможных» состояний; автодополнение и сужение работают идеально.

## 2. Результат запроса: data? и error? vs. взаимоисключающие варианты

Плохо:

```ts
interface ApiResult<T> {
  status: "ok" | "error";
  data?: T;
  error?: string;
}

function handle<T>(r: ApiResult<T>) {
  // нужны проверки на data/error в обоих случаях
}
```

Хорошо:

```ts
type ApiResult<T> = { status: "ok"; data: T } | { status: "error"; error: string };

function handle<T>(r: ApiResult<T>) {
  if (r.status === "ok") {
    r.data; // T — гарантированно
  } else {
    r.error; // string — гарантированно
  }
}
```
