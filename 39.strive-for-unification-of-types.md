## Стремитесь к унификации типов, а не к моделированию различий

Ключ идеи: вместо «разводить» типы под каждый вариант входных данных — нормализуйте на границе и работайте внутри с единым типом. Ниже короткие, приземлённые примеры.

### 1) API v1/v2 → один User

```ts
// Внешние различия:
type UserV1 = { id: string; full_name: string; mail: string };
type UserV2 = { id: string; name: string; email: string };

// Внутренний инвариант:
type User = { id: string; name: string; email: string };

function toUser(x: UserV1 | UserV2): User {
  return "full_name" in x
    ? { id: x.id, name: x.full_name, email: x.mail }
    : { id: x.id, name: x.name, email: x.email };
}
```

### 2. Даты: ISO/epoch → Date

```ts
type ExternalDate = string | number | Date;

function asDate(x: ExternalDate): Date {
  const d = x instanceof Date ? x : new Date(x);
  if (Number.isNaN(+d)) throw new Error("Invalid date");
  return d; // внутри везде Date
}
```

### 3. Деньги: доллары/цены-строки → «центы» (minor units)

```ts
type MoneyIn = number | string;

type Money = { cents: number; currency: "USD" | "EUR" };

function toMoney(amount: MoneyIn, currency: Money["currency"]): Money {
    const n = typeof amount === "string" ? parseFloat(amount) : amount;
    return { cents: Math.round(n \* 100), currency };
}
```

### 4. Разные события → общий Pointer

```ts
type Click = { type: "click"; x: number; y: number };
type Touch = { type: "touch"; clientX: number; clientY: number };

type Pointer = { x: number; y: number }; // единый внутренний

function toPointer(e: Click | Touch): Pointer {
  return "clientX" in e ? { x: e.clientX, y: e.clientY } : { x: e.x, y: e.y };
}
```

### 5. Разные регистры/форматы ролей → нормализованный Role

```ts
type Role = "admin" | "user" | "guest";

function toRole(raw: string): Role {
  const v = raw.trim().toLowerCase();
  return v === "admin" || v === "user" ? v : "guest";
}
```

### 6. Идентификаторы: number | string → брендированный Id

```ts
type Brand<K, T> = K & { \_\_brand: T };
type UserId = Brand<string, "UserId">;

function toUserId(x: number | string): UserId {
    return String(x) as UserId; // внутри — везде один тип
}
```

### 7. Конфиг: свободный ввод → полный нормализованный объект

```ts
type ConfigIn = Partial<{ retries: number | string; timeoutMs: number | string }>;
type Config = Readonly<{ retries: number; timeoutMs: number }>;

function makeConfig(inp: ConfigIn): Config {
  const retries = Math.max(0, Number(inp.retries ?? 3));
  const timeoutMs = Math.max(0, Number(inp.timeoutMs ?? 5000));
  return Object.freeze({ retries, timeoutMs });
}
```

### 8. Ошибки/успехи из разных библиотек → единый Result

```ts
// Разные источники:
type LibA<T> = { ok: true; value: T } | { ok: false; error: string };
type LibB<T> = { success: true; data: T } | { success: false; message: string };

// Единый формат:
type Result<T> = { ok: true; data: T } | { ok: false; reason: string };

function toResult<T>(x: LibA<T> | LibB<T>): Result<T> {
  if ("ok" in x) return x.ok ? { ok: true, data: x.value } : { ok: false, reason: x.error };
  else return x.success ? { ok: true, data: x.data } : { ok: false, reason: x.message };
}
```

### 9. Ключи snake/camel → единый доменный тип

```ts
type UserSnake = { user_id: string; first_name: string };
type UserCamel = { userId: string; firstName: string };
type UserCore = { id: string; name: string };

function toUserCore(u: UserSnake | UserCamel): UserCore {
  return "user_id" in u
    ? { id: u.user_id, name: u.first_name }
    : { id: u.userId, name: u.firstName };
}
```

### 10. Источники CSV/JSON → общий Product[]

```ts
type Product = { sku: string; title: string; priceCents: number };

async function loadProducts(file: File): Promise<Product[]> {
    const text = await file.text();
    if (file.name.endsWith(".json")) {
        const arr = JSON.parse(text) as Array<{ sku: string; title: string; price: number }>;
        return arr.map(x => ({ sku: x.sku, title: x.title, priceCents: Math.round(x.price _ 100) }));
    }
    // CSV: sku,title,price
    return text.trim().split("\n").slice(1).map(line => {
            const [sku, title, price] = line.split(",");
            return { sku, title, priceCents: Math.round(parseFloat(price) _ 100) };
            });
}
```

Итог: различия — на входе; унификация — сразу после.
Дальше код опирается на один, простой и предсказуемый тип — меньше проверок,
меньше ветвления, выше читаемость и надёжность.
