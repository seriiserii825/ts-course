## 45. Скрывайте небезопасные утверждения типов в хорошо типизированных функциях

Смысл правила: если без as any/утверждений не обойтись — спрячьте их внутри небольшой, хорошо типизированной функции. Снаружи — чистая, удобная сигнатура; внутри — минимум «грязи» с рантайм-проверками и тестами.
Ниже короткие, практичные примеры.

### 1) Обёртка над JSON.parse

```ts
type User = { id: string; email: string; name?: string };
export function parseUser(json: string): User {
  const u = JSON.parse(json) as unknown; // небезопасно — внутри
  if (
    typeof u === "object" &&
    u !== null &&
    typeof (u as any).id === "string" &&
    typeof (u as any).email === "string"
  ) {
    return { id: (u as any).id, email: (u as any).email, name: (u as any).name };
  }
  throw new Error("Invalid User payload");
}
// Внешний API: строго возвращает User или кидает исключение.
```

### 2) «Гарантированный» DOM-элемент

```ts
export function getRequiredEl<T extends Element = HTMLElement>(sel: string): T {
  const el = document.querySelector(sel) as T | null; // локальный cast
  if (!el) throw new Error(`Missing element: ${sel}`);
  return el;
}
// Снаружи: getRequiredEl<HTMLButtonElement>("#buy").addEventListener(...)
```

### 3) Нормализация даты из разнородных входов

```ts
type DateInput = string | number | Date;
export function asDate(x: DateInput): Date {
  const d = x instanceof Date ? x : new Date(x as any); // cast внутри
  if (Number.isNaN(+d)) throw new Error("Invalid date");
  return d;
}
```

### 4) Обёртка над «легаси»-библиотекой

```ts
// Допустим, старая библиотека принимает/возвращает "что угодно"
declare function legacyCall(config: any): any;
type LegacyConfig = { retries?: number; verbose?: boolean };
type Result<T> = { ok: true; data: T } | { ok: false; reason: string };
export async function call<T>(cfg: LegacyConfig): Promise<Result<T>> {
  try {
    const raw = await legacyCall(cfg as any); // прячем any здесь
    return { ok: true, data: raw as T }; // наружу — Result<T>
  } catch (e) {
    return { ok: false, reason: (e as Error).message ?? "Unknown error" };
  }
}
```

### 5) Безопасное преобразование «почти массива» → T[]

```ts
export function toArray<T>(xs: Iterable<T> | ArrayLike<T>): T[] {
  if (Symbol.iterator in Object(xs)) {
    return Array.from(xs as Iterable<T>); // cast внутри
  }
  const al = xs as ArrayLike<T>;
  return Array.from({ length: al.length }, (_, i) => al[i]);
}
// Пользователь получает чистый T[], без any.
```

### 6) Функция «узкого места» для словарей (Record)

```ts
export function mapValues<V, R>(
  rec: Record<string, V>,
  fn: (v: V, k: string) => R
): Record<string, R> {
  const out: Record<string, R> = Object.create(null);
  for (const k in rec) {
    // TS не всегда выводит верно тип for..in — используем локальный as
    out[k] = fn((rec as any)[k] as V, k);
  }
  return out;
}
// Снаружи: типобезопасный Record<string, R>.
```

### 7) Сужение «неизвестного» события до нужного вида

```ts
type Click = { type: "click"; x: number; y: number };
export function toClick(e: unknown): Click {
  const o = e as any; // внутри
  if (o && o.type === "click" && typeof o.x === "number" && typeof o.y === "number") {
    return { type: "click", x: o.x, y: o.y };
  }
  throw new Error("Not a Click event");
}
```

### 8) «Брендированный» идентификатор из любого ввода

```ts
type Brand<K, T> = K & { __brand: T };
export type UserId = Brand<string, "UserId">;
export function toUserId(x: string | number): UserId {
  return String(x) as UserId; // cast скрыт внутри
}
// Наружу уходит осмысленный тип, смешать с другим ID нельзя.
```

### Памятка по правилу

- Пишите узкую и точную сигнатуру (то, чем пользуются другие).
- Внутри функции:
- делайте рантайм-проверки формы данных;
- используйте unknown и локальные as any/приведения при необходимости;
- покрывайте такие функции тестами.
- Не «протекайте» any наружу: возвращайте строго типизированный результат.
